# Verbose 对比显示指南

## 新功能：三重对比显示

现在 verbose 模式会显示三个矩阵，让你能直观对比结果：

### 1. Result（实际结果）
显示你的实现的计算结果，带颜色编码：
- 🟢 **绿色**: 正确的值
- 🟡 **黄色**: 小误差
- 🔴 **红色**: 大误差

### 2. Expected（预期结果）  
显示 cuBLAS 的参考结果（正确答案）

### 3. Difference（差值）
显示 `Result - Expected` 的差值，带颜色编码：
- 🟢 **绿色**: 差值很小（正确）
- 🟡 **黄色**: 中等误差
- 🔴 **红色**: 大误差

## 实际示例

### 示例 1: one-one 初始化（8×8 全1矩阵）

```
Result:
0  :   64.000   56.000   48.000   40.000   32.000   24.000   16.000   8.000
1  :   0.000   0.000   0.000   0.000   0.000   0.000   0.000   0.000
...

Expected:
0  :8.000   8.000   8.000   8.000   8.000   8.000   8.000   8.000   
1  :8.000   8.000   8.000   8.000   8.000   8.000   8.000   8.000   
...

Difference (Result - Expected):
0  :   56.000   48.000   40.000   32.000   24.000   16.000   8.000   0.000
1  :   -8.000   -8.000   -8.000   -8.000   -8.000   -8.000   -8.000   -8.000
...
```

**分析**:
- **预期**: 每个元素应该是 8.0（8个1的和）
- **实际**: 第一行是递减序列，其他行是 0
- **问题**: WGMMA 的 layout 配置错误，可能是转置或索引问题

### 示例 2: row-col 初始化（行×列模式）

```
Result:
0  :   720.000   1200.000   1680.000   2160.000   ...
1  :   720.000   1200.000   1680.000   2160.000   ...
2  :   4960.000   4960.000   4960.000   4960.000   ...
3  :   0.000   0.000   0.000   0.000   ...
4  :     nan     nan     nan     nan   ...

Expected:
0  :0.000   0.000   0.000   0.000   ...
1  :0.000   16.000  32.000  48.000  ...
2  :0.000   32.000  64.000  96.000  ...
3  :0.000   48.000  96.000  144.000 ...
```

**分析**:
- **预期**: row[i] × col[j] = i × j 的模式
- **实际**: 完全错误的数值和 NaN
- **问题**: 严重的内存访问或计算错误

## 调试技巧

### 1. 识别转置问题
如果看到 `Result[i,j] == Expected[j,i]`，说明矩阵被转置了。

### 2. 识别索引偏移
如果看到规律性的偏移（如 `Result[i,j] == Expected[i+1,j]`），说明索引计算有偏移。

### 3. 识别 Layout 问题
如果看到：
- 某些行/列正确，其他错误 → 可能是 stride 问题
- 块状的错误模式 → 可能是 tile 大小问题
- 随机的 NaN → 可能是内存访问越界

### 4. 识别数值精度问题
如果看到：
- 大部分元素接近正确
- 误差很小且随机分布
- 没有明显模式

这通常是正常的浮点精度问题，不是算法错误。

## 配置建议

### 最佳调试配置
```yaml
gemm:
  verbose: true
  matrix_sizes: [8, 16]  # 小矩阵便于分析
  init_method: one-one   # 简单可预测
```

### 进阶调试配置
```yaml
gemm:
  verbose: true
  matrix_sizes: [16]
  init_method: row-col   # 能发现转置和索引问题
```

### 性能测试配置
```yaml
gemm:
  verbose: false         # 关闭详细输出
  matrix_sizes: [256, 512, 1024]
  init_method: rand-rand # 接近实际使用
```

## 显示控制

### 限制显示列数
对于大矩阵，默认只显示前 8 列以保持可读性。可以通过修改 `comparison_cols` 调整：

```cpp
print_config.comparison_cols = 4;  // 只显示前4列
```

### 关闭对比模式
如果只想看单个矩阵：

```cpp
print_config.show_comparison = false;  // 回到单矩阵显示
```

## 实际调试流程

### 步骤 1: 验证基本逻辑
```yaml
init_method: one-one
matrix_sizes: [8]
```
检查是否能得到正确的全1矩阵乘法结果。

### 步骤 2: 检查索引模式
```yaml
init_method: range-range
matrix_sizes: [8]
```
查看是否有规律性的索引错误。

### 步骤 3: 检查转置问题
```yaml
init_method: row-col
matrix_sizes: [8]
```
确认矩阵是否被意外转置。

### 步骤 4: 测试边界情况
```yaml
init_method: one-range
matrix_sizes: [16]
```
测试不同的输入组合。

## 总结

新的三重对比显示让调试变得非常直观：
- ✅ **看到实际结果**: 知道你的代码输出了什么
- ✅ **看到预期结果**: 知道正确答案应该是什么  
- ✅ **看到具体差异**: 知道错在哪里，错了多少
- ✅ **颜色编码**: 快速识别问题区域
- ✅ **模式识别**: 通过数值模式快速定位问题类型

这大大提高了调试效率，特别是对于复杂的 layout 和索引问题！